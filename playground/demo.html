<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <title>Demo</title>
</head>
<body>
    <style>
        :root {
            --editor-highlight: cyan;
            --editor-backlight: red;
            --editor-highlight-properties-opened: magenta;
            --editor-border: #99a;
            --editor-trash-bg: #fcc;
            --editor-trash-fg: #966;
            --editor-trash-border: #c99;
            --editor-context-menu-bg: #d0d0d7af;
            --editor-fg: #000;
            --editor-danger-fg: #e22;
        }
        body {
            display: flex;
            font-weight: 400;
            font-family: 'Ubuntu';
            color: var(--editor-fg);
        }
        .editor-canvas, .editor-pallete, .editor-trash, .editor-properties {
            min-height: 100px;
            min-width: 100px;
            border-radius: 5px;
            border: 1px solid var(--editor-border);
        }
        .editor-canvas {
            flex-grow: 1;
        }
        .editor-canvas:has(>.editor-info-h2):not(:has(.editor-component)){
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .editor-canvas:has(.editor-component)>.editor-info-h2{
            display: none;
        }
        .editor-pallete {
            width: fit-content;
        }
        .editor-trash {
            display: flex;
            justify-content: center;
            align-items: center;
            background: var(--editor-trash-bg);
            border: 1px solid var(--editor-trash-border);
        }
        .editor-trash>span {
            font-size: 64px;
            user-select: none;
            color: var(--editor-trash-fg);
        }
        .editor-component-header {
            font-size: 12px;
            padding: 1px;
            margin-right: 3px;
            width: max-content;
            background: var(--editor-highlight);
        }
        .editor-component[properties-opened]>.editor-component-header{
            background: var(--editor-highlight-properties-opened);
        }
        .editor-component-properties-button {
            font-size: 12px;
            vertical-align: sub;
            cursor: pointer;
        }
        .editor-pallete .editor-component {
            margin: 5px;
        }
        .editor-pallete .editor-component-properties-button{
            display: none;
        }
        .editor-component-content {
            border-top-right-radius: 5px;
            border-bottom-left-radius: 5px;
            border-bottom-right-radius: 5px;
            border: 1px solid var(--editor-highlight);
            transition: box-shadow .2s ease;
        }
        .editor-component[properties-opened]>.editor-component-content{
            border: 1px solid var(--editor-highlight-properties-opened);
        }
        .editor-component {
            user-select: none;
            cursor: grab;
            margin: 10px;
            width: fit-content;
            height: fit-content;
        }
        .editor-component:has(.editor-root-component),
        .editor-component-content:has(.editor-root-component),
        .editor-root-component{
            width: stretch;
            width: -moz-fill-available;
            width: -webkit-fill-available;
            height: calc(100% - 9px);
            cursor: initial;
        }
        .editor-component:has(.editor-root-component){
            margin: 0;
        }
        .editor-properties {
            min-width: 300px;
        }
        .editor-property {
            padding: 2px 5px;
            border-bottom: 1px solid var(--editor-border);
        }
        .editor-property:last-of-type {
            border-bottom: none;
        }
        .editor-property-label {
            display: inline-block;
            padding-right: 5px;
            min-width: 120px;
        }
        .editor-property-label::after {
            content: ':'
        }
        #editor-context-menu {
            position: absolute;
            display: none;
            cursor: pointer;
            user-select: none;
            border-radius: 10px;
            background: var(--editor-context-menu-bg);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px); 
            font-size: 14px;
        }
        #editor-context-menu>div{
            margin: 7px;
        }
        .editor-context-menu-icon{
            font-size: 16px;
            vertical-align: sub;
        }
    </style>
    <script>
        const ID_PREFIX = '_EditorElement-'
        const Sides = Object.freeze({
            LEFT: 'LEFT',
            TOP: 'TOP',
            RIGHT: 'RIGHT',
            BOTTOM: 'BOTTOM',
            INSIDE: 'INSIDE'
        })
        const OuterBacklight = Object.freeze({
            LEFT: '-10px 0 5px -5px var(--editor-backlight)',
            TOP: '0 -10px 5px -5px var(--editor-backlight)',
            RIGHT: '10px 0 5px -5px var(--editor-backlight)',
            BOTTOM: '0 10px 5px -5px var(--editor-backlight)'
        })
        const InnerBacklight = 'inset 0 0 5px 2px var(--editor-backlight)';
        const PropertyTypes = Object.freeze({
            TEXT: 'TEXT',
            COLOR: 'COLOR',
            NUMBER: 'NUMBER',
            VARIANTS: 'VARIANTS'
        })
        
        function generateId () { return ID_PREFIX + Math.random().toString(36).substring(2, 15) }
        
        function getComponentId (element) {
            let parent = element
            while (!parent.id.startsWith(ID_PREFIX) && parent !== null) {
                parent = parent.parentNode
            }
            return parent !== null ? parent.id : null
        }
        
        function getContainer (canvas, element) {
            let container = canvas.getComponentById(getComponentId(element))
            while (!container.container) {
                container = canvas.getComponentById(getComponentId(element.parentNode))
            }
            return container !== null ? container.id : null
        }
        
        function getClosestWithSide (parent, x, y) {
            let closest = null
            let minDist = Infinity
            let side = null
            for (const el of parent.children) {
                const rect = el.getBoundingClientRect()
                const dx = Math.max(rect.left - x, 0, x - rect.right)
                const dy = Math.max(rect.top - y, 0, y - rect.bottom)
                const dist = Math.sqrt(dx * dx + dy * dy)
                if (dist < minDist) {
                    minDist = dist
                    closest = el
                    if (dx === 0 && dy === 0) {
                        side = Sides.INSIDE
                    } else {
                        let horizSide = null
                        if (x < rect.left) horizSide = Sides.LEFT
                        else if (x > rect.right) horizSide = Sides.RIGHT
                        let vertSide = null
                        if (y < rect.top) vertSide = Sides.TOP
                        else if (y > rect.bottom) vertSide = Sides.BOTTOM
                        if (horizSide && !vertSide) {
                            side = horizSide
                        } else if (!horizSide && vertSide) {
                            side = vertSide
                        } else if (horizSide && vertSide) {
                            if (dx > dy) {
                                side = horizSide
                            } else if (dy > dx) {
                                side = vertSide
                            } else {
                                side = horizSide
                            }
                        } else {
                            side = null
                        }
                    }
                }
            }
            return {
                element: closest,
                side: side
            }
        }
        
        function showContextMenu (clientX, clientY, elements) {
            if (!document.hasOwnProperty('contextMenu')){
                document.contextMenu = document.createElement('div')
                document.contextMenu.id = 'editor-context-menu'
                document.querySelector('body').appendChild(document.contextMenu)
                window.onclick = event => {
                    hideContextMenu()
                }
            }
            document.contextMenu.replaceChildren()
            elements.forEach(element => {
                let element_element = document.createElement('div')
                element_element.innerHTML = `
                    <span class="material-symbols-outlined editor-context-menu-icon">${element.icon}</span>
                    <span>${element.label}</span>
                `
                element_element.style.color = element.color
                element_element.onclick = event => {
                    element.onclick(event)
                    hideContextMenu()
                }
                document.contextMenu.appendChild(element_element)
            })
            document.contextMenu.style.left = clientX + 'px'
            document.contextMenu.style.top = clientY + 'px'
            document.contextMenu.style.display = 'block'
        }

        function hideContextMenu () {
            if (document.hasOwnProperty('contextMenu')){
                document.contextMenu.style.display = 'none'
            }
        }


        class Component {
            constructor (name, innerHTML, canvas, container=false, parent=null, children=new Array(), properties=new Array()) {
                this.name = name
                this.container = container
                this.parent = parent
                this.children = children
                this.canvas = canvas
                this.properties = properties
                this.id = generateId()
                this.canvas.components.set(this.id, this)

                this.element = document.createElement('div')
                this.element.id = this.id
                this.element.classList.add('editor-component')
                this.element.setAttribute('draggable', true)

                this.element.innerHTML = `
                    <div class="editor-component-header">
                        <span class="material-symbols-outlined editor-component-properties-button">page_info</span>
                        ${this.name}
                    </div>
                    <div class="editor-component-content">${innerHTML}</div>
                `
                this.header = this.element.getElementsByClassName('editor-component-header')[0]
                this.propertiesButton = this.header.getElementsByClassName('editor-component-properties-button')[0]
                this.body = this.element.getElementsByClassName('editor-component-content')[0]
                
                this.context_menu_items = new Array()
                this.context_menu_items.push({ label: 'Открыть свойства', icon: 'page_info', color: 'var(--editor-fg)', onclick: ev => {
                    this.canvas.properties.display(this)
                }})
                if (this.canvas.root_component !== undefined){
                    this.context_menu_items.push({ label: 'Удалить', icon: 'delete', color: 'var(--editor-danger-fg)', onclick: ev => {
                        this.remove()
                    }})
                    this.context_menu_items.push({ label: 'Дублировать', icon: 'content_copy', color: 'var(--fg)', onclick: ev => {
                        this.insertAfter(this.copy())
                    }})
                    if (this.container) {
                        this.context_menu_items.push({ label: 'Дублировать без содержимого', icon: 'copy_all', color: 'var(--fg)', onclick: ev => {
                            this.canvas.properties.display(this)
                            let copy = this.copy()
                            copy.children = new Array()
                            copy.container_element.replaceChildren()
                            this.insertAfter(copy)
                        }})
                    }
                }

                this.element.ondragstart = event => {
                    event.dataTransfer.setData('plain/text', event.target.id)
                }

                this.body.onclick = this.header.onclick = event => {
                    event.stopPropagation()
                    hideContextMenu()
                    if (this.isInPalletes()) return
                    this.canvas.properties.display(this)
                }

                this.body.oncontextmenu = event => {
                    event.stopPropagation()
                    event.preventDefault()
                    if (!this.canvas.isComponentInPalletesById(this.id)) {
                        showContextMenu(event.clientX, event.clientY, this.context_menu_items)
                    }
                }
                
                if (this.container) {
                    this.container_element = this.body.querySelector(this.container)
                    this.element.ondragover = event => {
                        event.preventDefault()
                        event.stopPropagation()
                        const target_component = this.canvas.getComponentById(getComponentId(event.target))
                        const closest = getClosestWithSide(this.container_element, event.clientX, event.clientY);
                        if (closest.element && closest.side !== Sides.INSIDE) {
                            this.canvas.getComponentById(getComponentId(closest.element)).setOuterBacklight(closest.side)
                        } else {
                            this.setInnerBacklight()
                        }
                    }
                    this.element.ondragleave = event => {
                        event.stopPropagation()
                        if (this.canvas.backlight_component !== null){
                            this.canvas.backlight_component.setOuterBacklight(null)
                        }
                    }
                    this.element.ondrop = event => {
                        event.preventDefault()
                        event.stopPropagation()
                        if (this.canvas.backlight_component !== null){
                            this.canvas.backlight_component.setOuterBacklight(null)
                        }
                        if (this.canvas.isComponentInPalletesById(this.id)) return
                        const id = event.dataTransfer.getData('plain/text')
                        const target_component = this.canvas.getComponentById(getComponentId(event.target))
                        const component =   (this.canvas.isComponentInPalletesById(id) ? 
                                            this.canvas.getComponentById(id).copy(target_component) : 
                                            this.canvas.getComponentById(id))
                        try {
                            target_component.insertChild(component, event.clientX, event.clientY)
                            this.canvas.properties.display(component)
                        } catch (err) {
                            if (err.name !== 'HierarchyRequestError'){
                                throw err
                            }
                        }
                    }
                }
            }
            
            appendChild (component) {
                this.container_element.appendChild(component.element)
                this.children.push(component)
                if (component.parent !== null) {
                    component.parent.children.splice(component.parent.children.indexOf(component))
                }
                component.parent = this
            }

            insertAfter (component) {
                this.element.after(component.element)
                if (component.parent && component.parent !== this.parent) {
                    component.parent.children = component.parent.children.filter(c => c !== component);
                }
                if (!this.parent.children.includes(component)) {
                    this.parent.children.push(component);
                }
                component.parent = this.parent;
            }

            insertChild(component, clientX, clientY) {
                if (!this.container) {
                    return getContainer(this.canvas, this.element).insertChild(component, clientX, clientY)
                }
                const closest = getClosestWithSide(this.container_element, clientX, clientY);
                if (closest.element && closest.side !== Sides.INSIDE) {
                    switch (closest.side){
                        case Sides.LEFT:
                        case Sides.TOP:
                            this.container_element.insertBefore(component.element, closest.element)
                            break
                        case Sides.RIGHT:
                        case Sides.BOTTOM:
                            closest.element.after(component.element)
                            break
                    }
                } else {
                    this.container_element.appendChild(component.element);
                }
                if (component.parent && component.parent !== this) {
                    component.parent.children = component.parent.children.filter(c => c !== component);
                }
                if (!this.children.includes(component)) {
                    this.children.push(component);
                }
                component.parent = this;
            }

            copy(parent = null) {
                const newComponent = new Component(
                    this.name,
                    this.body.innerHTML,
                    this.canvas,
                    this.container,
                    null,
                    new Array(),
                    this.properties
                );
                if (newComponent.container){
                    newComponent.container_element.replaceChildren()
                    this.children.forEach(child => {
                        const childCopy = child.copy(newComponent);
                        newComponent.appendChild(childCopy);
                    });
                }
                if (parent) {
                    parent.appendChild(newComponent);
                }
                return newComponent;
            }
            
            remove () {
                this.element.remove()
                if (this.parent) {
                    this.parent.children.splice(this.parent.children.indexOf(this));
                }
                this.canvas.components.delete(this.id)
                this.canvas.properties.display(this.canvas.root_component)
            }

            isInPalletes () {
                return this.canvas.isComponentInPalletesById(this.id)
            }

            setOuterBacklight (side) {
                if (this.isInPalletes()) return
                if (this.canvas.backlight_component !== null) {
                    this.canvas.backlight_component.body.style.boxShadow = ''
                }
                this.canvas.backlight_component = this
                this.body.style.boxShadow = side === null ? '' : OuterBacklight[side]
            }
            
            setInnerBacklight (enabled=true) {
                if (this.isInPalletes()) return
                if (this.canvas.backlight_component !== null) {
                    this.canvas.backlight_component.body.style.boxShadow = ''
                }
                this.canvas.backlight_component = this
                this.body.style.boxShadow = enabled ? InnerBacklight : ''
            }
        }


        class Canvas {
            constructor (element, palletes, properties) {
                this.components = new Map()
                this.palletes = palletes
                this.properties = properties
                this.element = element
                this.children = new Array()
                this.backlight_component = null

                this.root_component = this.createComponent(
                    'root',
                    '<div class="editor-root-component"></div>',
                    '.editor-root-component',
                    [

                    ]
                )
                this.root_component.element.setAttribute('draggable', false)
                this.appendChild(this.root_component)
            }

            createComponent (name, innerHTML, container=false, properties=new Array()) {
                return new Component(name, innerHTML, this, container, null, new Array(), properties)
            }
            
            getComponentById (id) {
                return this.components.get(id)
            }
            
            isComponentInPalletesById (id) {
                return this.palletes.map(pallete => { return pallete.component_ids }).flat().includes(id)
            }
            
            appendChild (component) {
                this.element.appendChild(component.element)
                component.parent = null
            }

            insertChild(component, clientX, clientY) {
                const closest = getClosestWithSide(this.element, clientX, clientY);
                if (closest.element && closest.side !== Sides.INSIDE) {
                    switch (closest.side){
                        case Sides.LEFT:
                        case Sides.TOP:
                            this.element.insertBefore(component.element, closest.element)
                            break
                        case Sides.RIGHT:
                        case Sides.BOTTOM:
                            closest.element.after(component.element)
                            break
                    }
                } else {
                    this.element.appendChild(component.element);
                }
                if (component.parent && component.parent !== this) {
                    component.parent.children = component.parent.children.filter(c => c !== component);
                }
                if (!this.children.includes(component)) {
                    this.children.push(component);
                }
                component.parent = this;
            }
        }


        class Pallete {
            constructor (element) {
                this.element = element
                this.component_ids = []
            }
            
            addComponent (component) {
                this.component_ids.push(component.element.id)
                this.element.appendChild(component.element)
            }
            
            addComponents (components) {
                components.forEach(component => 
                    this.addComponent(component)
                )
            }
        }
        
        
        class Trash {
            constructor (element, canvas) {
                this.element = element
                this.canvas = canvas

                this.element.ondragover = (event) => {
                    event.preventDefault();
                }
                this.element.ondrop = (event) => {
                    event.preventDefault()
                    let component = this.canvas.getComponentById(event.dataTransfer.getData('plain/text'))
                    if (!component.isInPalletes()){
                        component.remove()
                    }
                }
            }
        }
        
        
        class Properties {
            constructor (element) {
                this.element = element
                this.current_component = null
            }

            display (component) {
                if (this.current_component !== null) {
                    this.current_component.element.removeAttribute('properties-opened')
                }
                if (component === null){
                    return this.element.replaceChildren()
                }
                component.element.setAttribute('properties-opened', true)
                this.element.innerHTML = `
                    <h2>${component.name}</h2>
                `
                component.properties.forEach(property => {
                    let property_element = document.createElement('div')
                    property_element.classList.add('editor-property')
                    property_element.innerHTML = `<span class="editor-property-label">${property.name}</span>`
                    switch (property.type){
                        case PropertyTypes.TEXT: {
                            let input = document.createElement('input')
                            input.setAttribute('type', 'text')
                            input.value = property.onload(component.body)
                            input.oninput = event => { property.onchange(component.body, event.target.value) }
                            property_element.appendChild(input)
                            break
                        }
                        case PropertyTypes.COLOR: {
                            let input = document.createElement('input')
                            input.setAttribute('type', 'color')
                            input.value = property.onload(component.body)
                            input.oninput = event => { property.onchange(component.body, event.target.value) }
                            property_element.appendChild(input)
                            break
                        }
                        case PropertyTypes.NUMBER: {
                            let input = document.createElement('input')
                            input.setAttribute('type', 'number')
                            input.setAttribute('min', property.args.min)
                            input.setAttribute('max', property.args.max)
                            input.setAttribute('step', property.args.step)
                            input.value = property.onload(component.body)
                            input.oninput = event => { property.onchange(component.body, event.target.value) }
                            property_element.appendChild(input)
                            break
                        }
                        case PropertyTypes.VARIANTS: {
                            let select = document.createElement('select')
                            property.args.options.forEach((value, key) => {
                                let option_element = document.createElement('option')
                                option_element.setAttribute('value', key)
                                option_element.innerText = value
                                select.appendChild(option_element)
                            })
                            select.value = property.onload(component.body)
                            select.onchange = event => { property.onchange(component.body, event.target.value) }
                            property_element.appendChild(select)
                            break
                        }
                    }
                    this.element.appendChild(property_element)
                })
                this.current_component = component
            }
        }


        class Property {
            constructor (type, name, onload, onchange, args) {
                this.type = type
                this.name = name
                this.onload = onload
                this.onchange = onchange
                this.args = args
            }
        }
    </script>
    <div>
        <div id="pallete" class="editor-pallete"></div>
        <div id="trash" class="editor-trash">
            <span class="material-symbols-outlined">delete_forever</span>
        </div>
    </div>
    <div id="canvas" class="editor-canvas">
        <h2 class="editor-info-h2">Переместите первый элемент из палитры</h2>
    </div>
    <div id="properties" class="editor-properties"></div>
    <style>
        .container{
            min-width: 40px;
            min-height: 40px;
            background: #2242;
            border: 1px solid #668;
            padding: 5px;
            margin: 5px;
            display: flex;
            flex-direction: row;
        }
    </style>
    <script>
        let pallete = new Pallete(document.getElementById('pallete'))
        let properties = new Properties(document.getElementById('properties'))
        let canvas = new Canvas(document.getElementById('canvas'), [pallete], properties)
        let trash = new Trash(document.getElementById('trash'), canvas)
        properties.display(canvas.root_component)
        pallete.addComponents([
            canvas.createComponent('Текст', `<span>Текст</span>`, false, [
                new Property(PropertyTypes.TEXT, 'Содержимое',
                    (element) => {
                        return element.querySelector('span').innerText
                    },
                    (element, value) => {
                        element.querySelector('span').innerText = value
                    }
                ),
                new Property(PropertyTypes.COLOR, 'Цвет текста',
                    (element) => {
                        return element.querySelector('span').style.color
                    },
                    (element, value) => {
                        element.querySelector('span').style.color = value
                    }
                ),
                new Property(PropertyTypes.NUMBER, 'Размер шрифта',
                    (element) => {
                        return window.getComputedStyle(element.querySelector('span')).getPropertyValue('font-size').slice(0, -2)
                    },
                    (element, value) => {
                        element.querySelector('span').style.fontSize = value + 'px'
                    },
                    { min: 1, max: 72, step: 1 }
                ),
            ]),
            canvas.createComponent('Поле ввода', `<input/>`, false),
            canvas.createComponent('Контейнер', `<div class="container"></div>`, '.container', [
                new Property(PropertyTypes.VARIANTS, 'Направление', 
                    (element) => {
                        return (element.querySelector('.container').style.flexDirection == 'column') ? 'column' : 'row'
                    },
                    (element, value) => {
                        element.querySelector('.container').style.flexDirection = (value == 'row' ? 'row' : 'column')
                    },
                    {
                        options: new Map([
                            ['row', 'по горизонтали'],
                            ['column', 'по вертикали']
                        ])
                    }
                )
            ])
        ])
    </script>
</body>
</html>